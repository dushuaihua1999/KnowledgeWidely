串口参数

**1.波特率**

串口通信时的速率。

如每秒钟传送1920个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），波特率为240Bd，比特率为10位*240个/秒=2400bps。

**2.数据位**
这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。

如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。

如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。

**每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。**由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。

**3.停止位**

> 用于表示单个数据包的最后一位。典型的值为1、1.5或2位。
>
> 停止位不仅表示传输的结束，并且提供计算机校正时钟同步的机会。
>
> 停止位的位数越多，不同时钟同步的容错程度越大，但同时数据传输率也越慢。

**4.校验位**

对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据不同步。

例如：需要传输“01001011”，数据中含有4个“1”，所以其奇校验位为“1”（如果数据中“1”的个数为奇数，则奇校验为“0”），同时把“01001011”传输给接收方，接收方收到数据后再一次计算奇偶性，“01001011”中仍然含有4个“1”，所以接收方计算出的奇校验位还是“1”，与发送方一致，表示此次传输过程中未发生错误。
**5.校验类型**

请注意，这里说的校验和上面说的校验位是不同的：校验位针对的是单个字节，校验类型针对的是单个数据帧。  

**6.Hex/ASCIII发送和显示**

底层的数据传输都是字节流，所以不管选择什么方式，都会被分解为一个一个的字节（2个十六进制位）。

![img](https://img-blog.csdn.net/20170621110923097?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2ODI4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

1.选择Hex发送就代表要发送的内容是十六进制数，由程序完成到Byte的转化。所以应该保证每个你要发送的数都是两位（1个字节）的，如果是7就应该写07，因为程序会每两位每两位地读。如果你选择了Hex发送，而输入的又是字符，比如你写了ab，那么就会被程序读为16进制的AB。



linux OpenFile的flag文档

https://man7.org/linux/man-pages/man2/open.2.html



O_NOCTTY ：该参数不会使打开的文件成为该进程的控制终端。如果没有指定这个标志，那么任何一个 输入都将会影响用户的进程。



###### 搞懂进程组、会话、控制终端关系，才能明白守护进程干嘛的？

https://www.eet-china.com/mp/a30051.html



###### Linux 串行终端，虚拟终端，伪终端，控制终端，控制台终端的理解

https://blog.csdn.net/wangsifu2009/article/details/6766298

 **终端**：输入和输出设备（键盘 + 显示器）。

**串行终端：**与机器的串口对应，每一个串口对应一个串行终端，串口对应的是物理终端。

**虚拟终端：**一台PC只有一套键盘和显示器，也就只有一套终端设备，但是可以通过Ctrl + Alt + F1 ~ Ctrl + Alt + F6切换到字符终端，相当于有6套虚拟的终端设备，它们共用同一套物理终端设备/dev/tty1 ~ /dev/tty6。

**伪终端：**虚拟终端和串行终端的数目是有限的，然而，网络终端和图形终端窗口的数目确实不受限制的，这是通过伪终端实现的。

**控制终端**：这是一个逻辑概念，即用户正在控制的终端，可以为串行终端，虚拟终端和伪终端。

**控制台终端：**控制台终端可认为是一个PC对应的一套键盘和显示器，所有虚拟终端是对应的都是同一控制台终端。



O_NONBLOCK与O_NDELAY的区别

O_NONBLOCK和O_NDELAY的结果是使I/O进入非阻塞模式（非阻塞）。当没有数据被读取或写缓冲区已满时，它将立即返回，而不搁置程序操作，直到有数据或写入完成。它们之间的区别在于，设置O_NDELAY会使I/O函数立即返回0，但另一个问题出现了，因为当读完文件时，返回也是0，所以不可能知道是哪种情况；因此，O_NONBLOCK产生了，它将在不能读取数据时返回-1，并设置errnotoEAGAIN。然而，应该注意的是，GNU C中的O_NDELAY只是为了与BSD程序兼容。事实上，O_NONBLOCK是作为一个宏定义使用的，O_NONBLOCK可以在ioctl中使用，但也可以在openTime设置中使用。





#### [Linux 阻塞与非阻塞串行读取](https://stackoom.com/cn_en/question/1l4n5)

https://stackoom.com/cn_en/question/1l4n5

1.阻塞与非阻塞的传统定义基于读取调用何时返回到程序以及是否将数据存储在您的程序的读取缓冲区中。阻塞读取是默认模式，除非通过使用O_NONBLOCK或O_NDELAY标志打开串行终端来请求非阻塞。



**规范模式：**

1.对于串行终端的阻塞规范读取调用，将始终在提供的缓冲区中返回一行文本（除非发生错误）。只要接受和处理行终止字符，read调用就会阻塞。(即暂停程序的执行)

2.串行终端的非阻塞规范读取调用将始终“立即”返回。读取可能会或可能不会返回任何数据。如果(自上次read调用以来)至少有一行文本被接受并存储在系统缓冲区中，那么最旧的行将从系统缓冲区中删除并复制到程序的缓冲区buf中。返回码将指示数据长度。如果(自上次read调用以来)尚未接受和处理行终止字符，则没有（完整的）文本行可用。read()将返回一个EAGAIN错误(即-1返回代码和errno设置成EAGAIN)。然后您的程序可以执行一些计算，或从另一个设备请求I/O,或延迟睡眠。在任意延迟或通过poll()或select()通知后，您的程序可以重试read（）。



**非规范模式：**

当串口终端配置为非规范模式时，应使用termios c_cc数组元素VMIN和VTIME来控制阻塞。但这需要以默认阻塞打开，即不指定O_NONBLOCK

，否则O_NONBLOCK将优先于VMIN和VTIME规范。并且read()会将errno设置为EAGAIN并在没有可用数据时立即返回-1而不是0。termios 手册页将 ( **c_cc**数组索引) **VMIN**描述为非规范读取的最小字符数，将 ( **c_cc**数组索引) **VTIME**描述为非规范读取的超时时间(以分秒为单位)

您的程序应调整**VMIN**以适应预期的典型消息或数据报长度和/或每次**read()**检索和处理的数据的最小大小。

**VTIME**应由您的程序调整，以适应预期的串行数据的典型突发或到达率和/或等待数据或数据的最长时间。

**VMIN**和**VTIME**值相互作用以确定何时应返回读取的标准；

它们的确切含义取决于它们中的哪些是非零的。



**1.*VMIN = 0 and VTIME = 0*** 

这是一个完全非阻塞的读取——直接从驱动程序的输入队列立即满足调用。如果数据可用，它会被传输到调用者的缓冲区，最多 nbytes 并返回,否则立即返回零以指示“无数据”。我们会注意到这是对串行端口的“轮询”，这几乎总是一个坏主意。如果重复执行，它会消耗大量的处理器时间并且效率极低。除非您真的非常清楚自己在做什么，否则不要使用这种模式。

**2.*VMIN = 0 and VTIME > 0***

如果输入队列中的数据可用，它会被传输到调用者的缓冲区，最多为 nbytes，并立即返回给调用者。否则，驱动程序阻塞直到数据到达，或者当 VTIME 从调用开始到十分之一到期时,如果计时器到期而没有数据，则返回零。*.单个字节足以满足此读取调用，但如果输入队列中有更多可用字节，则将其返回给调用者。请注意，这是一个整体计时器，而不是字符间计时器。

**3.*VMIN > 0 and VTIME > 0*** 

当 VMIN 字符已传输到调用者的缓冲区时，或者当 VTIME 十分之一在字符之间到期时，就会满足 read()。由于此计时器在第一个字符到达之前不会启动，因此如果串行线路空闲，则此调用可能会无限期阻塞

这是最常见的操作模式，我们认为 VTIME 是字符间超时，而不是整体超时。

**4.*VMIN > 0 and VTIME = 0***

这是一个计数读取，仅当至少 VMIN 个字符已传输到调用者的缓冲区时才满足 - 不涉及计时组件，可以从驱动程序的输入队列（调用可以立即返回）或通过等待新数据到达来满足此读取：在这方面，调用可能会无限期地阻塞，我们认为，如果 nbytes 小于 VMIN，则这是未定义的行为。



**tips**

请注意，当 VMIN=1 时，VTIME 规范将无关紧要。任何数据的可用性将始终满足单个字节的最小标准，因此可以忽略时间标准（因为它将是具有非零 VMIN 的字符间时间规范）。

“非阻塞”的传统定义是您的调用程序在系统调用期间不会被抢占，并且（几乎）立即获得控制权。

要获得（无条件和）立即返回（对于非规范读取），请设置 VMIN=0 和 VTIME=0（带有伴随警告）。



StackOverflow:[Serial read in C returning no data](https://stackoverflow.com/questions/50863379/serial-read-in-c-returning-no-data)



可能的解决方案:

1.无返回重发，必须保证后面来的命令不能影响平台接受重发命令的结果。

2.打开文件尝试以阻塞的方式进行。

3.采取termios非规范方式阻塞读取 VMIN = 0 and VTIME > 0

4.遍历读取port加一个间隔

